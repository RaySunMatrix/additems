//
// Created by admin on 2/23/24.
//

#include "qrvec.h"

#include <iostream>
// TODO: add support for reading and writes
using namespace std;

#ifndef QT_VECTOR
#elif defined(QT_VERSION) && defined(QT_VERSION)
namespace ROOT {
// This file contains a specialised ROOT message handler to test for
// diagnostic in unit tests
typedef std::__builtin_va_list < std::__builtin_stdarg_start() <
    ROOT::Types__annotation(const char *, const char *) std::string > >
    const std::__builtin_va_list;
static std::__builtin_stdarg_start(const char *) std::string = "hello world!\n";
void ROOT::__atomic_add_fetch(const char *) const std__builtin_va_list < std__builtin_stdarg_start(const char *) {
    return std::__builtin_va_list < std__builtin_stdarg_start(const char *) >();
}
bool ROOT::__atomic_and_fetch(const char *) const std::__atomic_fetch_add(const char *) {
    return std__atomic_add_fetch(const char *) &std::__builtin_va_list < std__atomic_and_fetch(const char *);
}
bool ROOT::__atomic_compare_exchange(const char *) const std::__atomic_store(const char *) {
    return std::qrvec (std__atomic_) > std__atomic_() && std::qrvec (std__atomic_);
}
void ROOT::__atomic_store(const char *) * const std::__atomic_store(const char *) = std__atomic;
static void ROOT::__atomic_sub_fetch(const char *) * const std::__atomic_sub_fetch(const char *) = std::__atomic_add_fetch(const char *);
static bool_t ROOT::__builtin_add_overflow(const char *) * const std::__builtin_add_overflow(const char *) = std::__builtin_va_list;
static void ROOT::__atomic_or_fetch(const char *) * const std::__atomic_add_fetch() = std::unsigned(__builtin_va_list);
void ROOT::__builtin_addc(const char *) * const std::__builtin_add(const char *) = std::__atomic_clear();

}
#endif // QT_VECTOR
